-- | Defines various utility routines to assist in writing HUnit tests.
module Test.Utils(assertParse,
                  assertParseFail,
                  assertParseError,
                  parseRest,
                  parseContext,
                  makePos,
                  testQuickCheck)
       where

import qualified Data.List as List
import Control.Monad
import Data.Text.Lazy (Text)
import qualified Data.Text.Lazy as Text
import Test.HUnit
import Text.Parsec.Char
import Text.Parsec.Error
import Text.Parsec.Pos
import Text.Parsec.Prim
import Text.Parsec.Text.Lazy
import Text.Parsec.Error (ParseError)
import qualified Test.QuickCheck as QC

parserInputSource = "unit tests"

-- | Runs the supplied parser and returns the result of the parser plus any
--   unused input.
parseRest :: GenParser st a -> GenParser st (a, Text)
parseRest p =
  do val <- p
     rest <- many anyChar
     return (val, Text.pack rest)

-- | Runs the supplied parser, and returns the input observed upon entry, the
--   result of the parser, and the remaining input.
parseContext :: GenParser st a ->
                GenParser st (Text, a, Text)
parseContext p =
  do input <- getInput
     val <- p
     rest <- getInput
     return (input, val, rest)

-- | Asserts that a parser, when executed on the supplied input, succeeds and
--   returns the expected result.  This function sets up the parser's source
--   location information to match positions generated by 'makePos'.
assertParse :: (Eq a, Show a) =>
               a                 -- ^ The expected result
               -> GenParser () a -- ^ The parser to be tested
               -> Text           -- ^ The parser input
               -> Assertion
assertParse expected parser input =
  case parse parser parserInputSource input of
    Left err ->
      assertFailure (concat ["Expected result ",
                             show expected,
                             "; got parse error: ",
                             show err])
    Right actual -> assertEqual "" expected actual

-- | Asserts that a parser fails on the given input.
assertParseFail :: (Show a)
                   => GenParser () a -- ^ The parser to be tested
                   -> Text           -- ^ The parser input
                   -> Assertion
assertParseFail parser input =
  case parse parser parserInputSource input of
    Left _ -> return ()
    Right val ->
      assertFailure ("Expected parse failure; got result: " ++ show val)

-- | Asserts that the indicated 'Message' is part of the result of running a
--   parser on the supplied input.
assertParseError :: (Show a)
                    => GenParser () a
                    -- ^ The parser to be tested
                    -> Text
                    -- ^ The parser input
                    -> Message
                    -- ^ The expected error message
                    -> Assertion
assertParseError parser input expectedMsg =
  case parse parser parserInputSource input of
    Left err ->
      do let actualMsgs = errorMessages err
         unless (any (msgEq expectedMsg) actualMsgs)
           (assertFailure
            (concat ["Parse failed, but expected message\n  ",
                     showMsg expectedMsg,
                     "\n; got message",
                     if (length actualMsgs == 1) then "" else "s",
                     "\n  ",
                     List.intercalate "\n  " (map showMsg actualMsgs)]))
    Right val ->
      assertFailure ("Expected parse failure; got result: " ++ show val)

-- | Constructs a Parsec 'SourcePos' instance with the given line and column;
--   the result's name matches that in positions created by 'assertParse'.
makePos :: Line -> Column -> SourcePos
makePos line col = newPos parserInputSource line col

-- | Wraps a QuickCheck property in an HUnit test case, using given args to
--   specify QuickCheck's behavior.  Copied from
--   <http://blog.holdenkarau.com/2008/07/integrating-your-hunit-or-other-tests.html>.
testQuickCheck :: (QC.Testable a) => QC.Args -> a -> Test
testQuickCheck args qcProp =
  TestCase (
    do result <- QC.quickCheckWithResult args qcProp
       case result of
         (QC.Success { }) -> return ()
         (QC.GaveUp { }) ->
           assertFailure (
             "Arguments exhausted after "
             ++ show (QC.numTests result)
             ++ (if (QC.numTests result) == 1 then " test" else " tests"))
         (QC.Failure { }) ->
           assertFailure (QC.reason result)
         (QC.NoExpectedFailure { }) ->
           assertFailure "No expected failure"
         (QC.InsufficientCoverage { }) ->
           assertFailure "insufficient coverage")

-- | Equality comparison for 'Message' values that, unlike '(==)', actually
--   compares the contents of the message string.
msgEq :: Message -> Message -> Bool
msgEq (SysUnExpect m1) (SysUnExpect m2) = m1 == m2
msgEq (UnExpect m1) (UnExpect m2) = m1 == m2
msgEq (Expect m1) (Expect m2) = m1 == m2
msgEq (Message m1) (Message m2) = m1 == m1
msgEq _ _ = False

-- | Generates external representation of 'Message' for assertion messages.
showMsg :: Message -> String
showMsg (SysUnExpect msg) = "SysUnExpect: " ++ msg
showMsg (UnExpect msg) = "UnExpect: " ++ msg
showMsg (Expect msg) = "Expect: " ++ msg
showMsg (Message msg) = "Message: " ++ msg
